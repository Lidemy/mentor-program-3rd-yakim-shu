## CSS 預處理器是什麼？
現代網頁開發工程越來越複雜，以往的 CSS 寫法不具彈性也不好維護，如果要寫大量的 CSS 會是個令人火大的工作，所以 CSS 預處理器的出現就是要解決這個問題。

CSS Preprocessor 跟傳統 CSS 差異滿大的，從選擇器嵌套就能省下不少麻煩（但要小心嵌套太多層反而不好閱讀），可以讓我們寫變數、function、繼承，還有不少內建函式幫助開發的效率。

值得一提的是 extend 寫法可以有效降低 CSS 檔案大小，因為編譯出來的 CSS 會把所有繼承到的樣式集中在一起。

市面上最常見的預處理器有 SASS/SCSS, LESS, Stylus 三套，功能都差不多，語法上些微差異。

目前只試過 SASS/SCSS 這套，不過因為 SASS 比較嚴謹，所以我比較偏好 SCSS，因為可以兼容傳統 CSS 也不會報錯。

## 我們可以不用它嗎？
如果是很小的專案，不用也罷，但要是專案大到一定程度，為了準時下班會建議採用。

---
## 請舉出任何一個跟 HTTP Cache 有關的 Header 並說明其作用。

#### Cache 是什麼？

簡單來說就是一個省流量的機制，當你連上某一個網站時，可以試同是把該網頁的所有資源下載回來。

假設過兩秒後按了重新整理，瀏覽器又重複下載一遍，如果該網頁一個月才會更新，聽起來是不是很浪費流量，不論是對 Client 或 Server 都是浪費，有沒有什麼辦法可以讓**未更新的資源暫存在某個地方**？

有的，這機制就是快取 Cache（ 中國翻譯是緩存 ）

而快取是個滿廣泛的概念，要實作有分幾種類型：
- CPU (L1, L2 cache)
- 瀏覽器 (HTTP header)
- Server (Redius, Memchached)

以下討論都是關於 HTTP 層面的快取機制。

---

#### Cache-Control 指令

Cache-Control 是一個 HTTP/1.1 後引入的表頭，其中有不同屬性可以設定。

新鮮度：
- `max-age`
    - 單位是秒，意思是 `n` 秒後才會過期。
    - 為了解決 `expire` 時間不同步的問題，相對時間 `max-age` 是個比較好的做法
    - **不會發送跟 Server 確認的 Request，只要檢查時間沒過期就好**

快取的方式：
- `no-store`: 表示完全不使用快取，意思是每次都要從 Server 拿資料
- `no-cache`: 易被字面混肴的屬性，其實**可以存快取，會先發個 request 去 Server 確認檔案是否變動**
    - 「 未更新就用快取、更新了不用快取 」
    - 效果跟使用 `max-age 搭配 Etag` 是一樣的，但會主動查看檔案有沒有變動，是個更方便的內建屬性。

聽起來 `no-cache` 是個很方便的屬性，但還是會發一個跟 Server 確認的 request，所以如果想要更省 request 的數量，一個好方法是把 html 檔案設成 `no-cache`，而裡面比較少更新的**靜態檔案 ( js, css ) 設置 `max-age`，且把 ETag 值實作在檔名上**。

> ETag : 可以想像成將檔案內容經過雜湊 hash 的一組字串，一但檔案更新、ETag 必定跟著變化。

這樣一來，靜態檔案如果有變化會帶動 js 檔名更新，而 `no-cache` 就會發現 html 內容有更新，意思是**只要發送一個的 request** 就可以偵測到網頁裡所有檔案的更新與否。

參考資料：
- [循序漸進理解 HTTP Cache 機制](https://blog.techbridge.cc/2017/06/17/cache-introduction/)
---
## Stack 跟 Queue 的差別是什麼？

兩者都是一種資料結構，資料結構可以理解成某種特定形式的資料，不同資料結構會有不同類型的特性。

比如說常用的陣列 Array，會有 length 的性質、物件 Object 也是一種資料結構，會有 key & value 相對應的特性。

### 所以什麼是堆疊 stack，你有打過羽毛球嗎？

> 大原則是： "Last in, First out" ( LIFO ) => 第一個進去、會最後一個出來

可以**想像成從羽毛球的罐子拿球**，因為盒身塞得剛剛好，所以你永遠只能拿最外面那一個，要想取得最裡面那一個，你只能把所有的球都拿出來，不可能從前面或中間抽出來。

這就是 stack。 

符合從下疊到上面，由上取到下的特性。

```javascript
stack.push('ball_1');
stack.push('ball_2');
stack.push('ball_3');

/* 羽毛球罐 *\ => 上方開口，放求、取球的唯一入口
    ball_3
    ball_2
    ball_1
\* ------- */

stack.pop() // 'ball_3' => 最外面
stack.pop() // 'ball_2' => 最外面

/* 羽毛球罐 *\
    ball_1
\* ------- */

stack.push('ball_4');

/* 羽毛球罐 *\
    ball_4
    ball_1
\* ------- */
```


### 那佇列 Queue 又是什麼？

其實也很好理解，跟剛剛介紹的 Stack 很像，差別在於**拿球**的方向不一樣。

> 大原則是： "First In, First Out" ( FIFO ) => 第一個進去、第一個出來

以剛剛的羽毛球為例，Queue 就是個傲嬌版的羽毛球罐，放球的動作跟剛剛一樣，都是從上方開口放進去，這部分跟 Stack 一樣懂得人情世故。

**而一但當你想要拿球時，淘氣的罐罐就會把上方開口關起來，同時把下方底部打開、讓你從底下拿球**。

這就是 Queue。 

符合從下疊到上面，由下取到上的特性。

```javascript
queue.push('ball_1');
queue.push('ball_2');
queue.push('ball_3');

/* 羽毛球罐 *\ => 上方開口，放球從這裡
    ball_3
    ball_2
    ball_1
\* ------- */ => 下方開口，拿球從這裡

stack.pop() // 'ball_1' => 最裡面
stack.pop() // 'ball_2' => 最裡面

/* 羽毛球罐 *\
    ball_3
\* ------- */ => 球 1, 2 從這拿出去 (跟 stack 不同的地方)

stack.push('ball_4');

/* 羽毛球罐 *\
    ball_4
    ball_3
\* ------- */
```

---

## 請去查詢資料並解釋 CSS Selector 的權重是如何計算的（不要複製貼上，請自己思考過一遍再自己寫出來）

在討論權重之前，有個很重要的前提是，權重只存在於 **同個選擇器** 之間，這點務必要清楚。


而 CSS 權重指的就是，當「 同一個選擇器寫了**相同樣屬性的樣式**，瀏覽器要依據權重等級、來決定哪一個為優先 」。

而其中會影響到的因素有幾種（由大到小）：
- CSS: `!important`
- HTML: `行內樣式`
- CSS: `選擇器`

以上代表會影響到 CSS 權重的因素，可以想像成一種分數，每個因素加權的比例不同，最後累計成權重分數。

雖說是分數，但不是很簡單的相加起來就好，可以想像成是一張列表，各欄位紀錄著分數，從最高層級（ 最左邊 ）開始檢查，如果**左邊可以比較出高低，那右邊加權分數小的欄位就不用看了**。

| !important | 行內樣式 | 選擇器 (id) | 選擇器 (class) | 選擇器 (元素) |
| --- | --- | --- | --- | --- |
| 最高等級 | 高 | 高  | 低 | 最低 |
| 0 | 0 | 0 | 0 | 0 |


```
// 當同元素發生屬性衝突時：
-> 比較兩者權重高低
    -> 權重分數高：瀏覽器顯示
    -> 權重分數低：被蓋過去
-> 兩者權重相等 
    -> 前面的：被蓋過去
    -> 後面的：瀏覽器顯示
```

---

### 權重比較開始

直接看以下兩者的樣式衝突：
```css
.box {
    color: pink!important;
}

#wrapper div.box {
    color:blue;
}
```

- 第一個 `.box` 有 `class` & 大魔王 `!important`

| !important | inline | id | class | element |
| --- | --- | --- | --- | --- |
| 1 | 0 | 0 | 1 | 0 |

- 第二個 `.box` 有 `id & class & element`

| !important | inline | id | class | element |
| --- | --- | --- | --- | --- |
| 0 | 0 | 1 | 1 | 1 |

最後是哪邊獲勝呢？

很明顯是第一個有加 `!important` 的，還記得前面說了左邊要是可以分出高下，右邊就算加權分數再高也無濟於事。

#### 關於 `!important`

所以大家才會說寫 CSS 要很小心 `!important` 的使用，因為一但你在前面加上 `!important`，後面的樣式要企圖用權重把它蓋過去非常困難（ 最後很有可能會變成一堆 `!important` 蓋 `!important` ），下場就是被同事討厭。

所以建議是一般寫 CSS，除了唯一的元素 ( 像 `header`、`footer`... )，想要保有後續維護的彈性，最好是都用 class 來寫 CSS，以保持權重不要太高，後續才可以**輕鬆利用權重的特性、去蓋掉前面的樣式**，也不需要用到 `!important`。

---
### 既然討論到權重，就不得不提一下繼承

繼承是個滿容易搞混的地方，因為 CSS 有繼承的特性，意思是子元素會繼承父元素的**部分屬性**，注意是部分、不是全部喔！

有繼承特性的屬性通常是文字相關的，例如 `font-family, color`，原因也非常合理，因為通常我們不會在網頁裡放超多不同字型，所以只要設置一次字型，裡面的內容都只要繼承下去就好。


且所有的 CSS 屬性都可以去改變是否繼承 (`inherit, initial,unset`)，不過通常不會這樣改，因為**如果沒有很清楚哪些子元素有調整到繼承屬性，一但改了父元素，底下子元素繼承的屬性都會影響到**。

所以當 debug CSS 發現有元素怎麼跟想像中的不一樣，除了權重的觀念沒搞清楚，也很有可能只是繼承自父元素的樣式。

### 權重討論只在於同個選擇器

前面強調很多次**同個選擇器**，因為 CSS 權重跟繼承的概念容易混肴，看以下範例：

```html
<div class="wrapper">
    wrapper
    <div class="box">
        box
    </div>
</div>
```

```css
.wrapper {
  color: red!important;
}
.box {
  color: green;
}
```

試問 `.box` 最後會是什麼顏色？

答案是綠色。


- 從繼承的角度來看：
    - `color` 這屬性預設是會繼承的，**所以 `.box` 一開始是繼承自 `.wrapper` 的紅色，但子元素的樣式永遠高於繼承屬性**，所以 `.box` 變成綠色。
- 從權重的角度來看：
    - 因為**兩者是不同元素**，所以就算 `.wrapper` 加了權重最高等級的 `!important`，也絲毫**不會影響**到 `.box`，意思是說這範例跟權重一點關係都沒有。



